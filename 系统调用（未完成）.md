



## 系统调用

### 访问用户内存

#### 实验目的

作为系统调用的一部分，内核必须经常通过用户程序提供的指针访问内存。内核在这样做时必须非常小心，因为用户可以传递一个空指针、一个指向未映射虚拟内存的指针或一个指向内核虚拟地址空间的指针。通过终止违规进程并释放其资源，必须拒绝所有这些类型的无效指针，而不会对内核或其他正在运行的进程造成损害

#### 实现方法

文档中提供了两种实现的方法

无论哪种情况，都需要确保不会“泄漏”资源。例如，假设系统调用使用`malloc()`. 如果之后遇到无效的用户指针，必须确保释放锁定或释放内存页面

+ 验证用户提供的指针的有效性，然后取消引用它。需要查看`userprog/pagedir.c`和`threads/vaddr.h`中的函数

+ 只检查用户指针是否指向下方的PHYS_BASE，然后取消引用它。无效的用户指针将导致“页面错误”，可以通过修改代码的处理`page_fault()`在`userprog/exception.c`。如果无效指针导致页面错误，则更难处理，因为无法从内存访问中返回错误代码。因此，对于那些想要尝试后一种技术的人，我们将提供一些有用的代码：

  ```C
  /* 在用户虚拟地址 UADDR 读取一个字节。
     UADDR 必须低于 PHYS_BASE。
     如果成功则返回字节值，如果出现段错误则返回 -1
     发生。*/
  static int
  get_user (const uint8_t *uaddr)
  {
    int result;
    asm ("movl $1f, %0; movzbl %1, %0; 1:"
         ："=&a"(result) : "m"(*uaddr));
    return result;
  }
   
  /* 将 BYTE 写入用户地址 UDST。
     UDST 必须低于 PHYS_BASE。
     如果成功则返回真，如果发生段错误则返回假。*/
  static bool
  put_user (uint8_t *udst, uint8_t byte)
  {
    int error_code;
    asm ("movl $1f, %0; movb %b2, %1; 1:"
         : "=&a" (error_code), "=m" (*udst) : "q" (byte));
    return error_code != -1;
  }
  ```

#### 实现代码

源代码使用第二种方法

```c
/* Method in document to handle special situation */
static int
get_user (const uint8_t *uaddr)
{
  int result;
  asm ("movl $1f, %0; movzbl %1, %0; 1:"
       : "=&a" (result) : "m" (*uaddr));
  return result;
}

/* New method to check the address and pages to pass test sc-bad-boundary2, execute */
void *
check_ptr2(const void *vaddr)
{
    /* Judge address */
    if (!is_user_vaddr(vaddr))
    {
        exit_special();
    }
    /* Judge the page */
    void *ptr = pagedir_get_page(thread_current()->pagedir, vaddr);
    if (!ptr)
    {
        exit_special();
    }
    /* Judge the content of page */
    uint8_t *check_byteptr = (uint8_t *)vaddr;
    for (uint8_t i = 0; i < 4; i++)
    {
        if (get_user(check_byteptr + i) == -1)
        {
            exit_special();
        }
    }

    return ptr;
}
```

`exit_special()`作用是若三种情况中有任一不符合，则将`exit_code`设为-1，并终止用户进程，代码如下：

```c
void exit_special(void){
  thread_current()->st_exit = -1;
  thread_exit();
}
```

### 说明

实现以下十三个系统调用（共二十个），列出的原型存储在`lib/user/syscall.h`

```c
/* Projects 2 and later. */
void halt (void) NO_RETURN;
void exit (int status) NO_RETURN;
pid_t exec (const char *file);
int wait (pid_t);
bool create (const char *file, unsigned initial_size);
bool remove (const char *file);
int open (const char *file);
int filesize (int fd);
int read (int fd, void *buffer, unsigned length);
int write (int fd, const void *buffer, unsigned length);
void seek (int fd, unsigned position);
unsigned tell (int fd);
void close (int fd);
```

每个系统调用的系统调用号在`lib/syscall-nr.h`中定义：

（此处仅摘出Project2有关的系统调用）

```c
SYS_HALT,                   /* Halt the operating system. */
SYS_EXIT,                   /* Terminate this process. */
SYS_EXEC,                   /* Start another process. */
SYS_WAIT,                   /* Wait for a child process to die. */
SYS_CREATE,                 /* Create a file. */
SYS_REMOVE,                 /* Delete a file. */
SYS_OPEN,                   /* Open a file. */
SYS_FILESIZE,               /* Obtain a file's size. */
SYS_READ,                   /* Read from a file. */
SYS_WRITE,                  /* Write to a file. */
SYS_SEEK,                   /* Change position in a file. */
SYS_TELL,                   /* Report current position in a file. */
SYS_CLOSE,                  /* Close a file. */
```

### 数据结构

在`thread/thread.h`中修改thread的结构用于完成后续实验

```c
/* Our implementation for struct thread to store useful information */
    /* Structure for Task2 */
    struct list childs;                 /* The list of childs */
    struct child * thread_child;        /* Store the child of this thread */
    int st_exit;                        /* Exit status */
    struct semaphore sema;              /* Control the child process's logic, finish parent waiting for child */
    bool success;                       /* Judge whehter the child's thread execute successfully */
    struct thread* parent;              /* Parent thread of the thread */
    
    /* Structure for Task3 */
    struct list files;                  /* List of opened files */
    int file_fd;                        /* File's descriptor */
    struct file * file_owned;           /* The file opened */

```

### syscall_init()

#### 作用

初始化系统调用，通过`syscall`函数指针数组来存储要实现的13个系统调用

> The skeleton implementation we provide "handles" system calls by terminating the process. It will need to retrieve the system call number, then any system call arguments, and carry out appropriate actions.

即在`syscall_handler()`中进行检索系统调用号，识别运行哪一个系统调用，从而执行对应操作

#### 实现

定义系统调用函数指针数组和原型

```c
#define max_syscall 20
/* Our implementation for storing the array of system calls for Task2 and Task3 */
static void (*syscalls[max_syscall])(struct intr_frame *);

/* Our implementation for Task2: syscall halt,exec,wait and practice */
void sys_halt(struct intr_frame *f); /* syscall halt. */
void sys_exit(struct intr_frame *f); /* syscall exit. */
void sys_exec(struct intr_frame *f); /* syscall exec. */

/* Our implementation for Task3: syscall create, remove, open, filesize, read, write, seek, tell, and close */
void sys_create(struct intr_frame *f);   /* syscall create */
void sys_remove(struct intr_frame *f);   /* syscall remove */
void sys_open(struct intr_frame *f);     /* syscall open */
void sys_wait(struct intr_frame *f);     /*syscall wait */
void sys_filesize(struct intr_frame *f); /* syscall filesize */
void sys_read(struct intr_frame *f);     /* syscall read */
void sys_write(struct intr_frame *f);    /* syscall write */
void sys_seek(struct intr_frame *f);     /* syscall seek */
void sys_tell(struct intr_frame *f);     /* syscall tell */
void sys_close(struct intr_frame *f);    /* syscall close */
static void syscall_handler(struct intr_frame *);
struct thread_file *find_file_id(int fd);
```

`syscall_init()`实现：

```c
void syscall_init(void)
{
    intr_register_int(0x30, 3, INTR_ON, syscall_handler, "syscall");
    /* Our implementation for Task2: initialize halt,exit,exec */
    syscalls[SYS_HALT] = &sys_halt;
    syscalls[SYS_EXIT] = &sys_exit;
    syscalls[SYS_EXEC] = &sys_exec;
    /* Our implementation for Task3: initialize create, remove, open, filesize, read, write, seek, tell, and close */
    syscalls[SYS_WAIT] = &sys_wait;
    syscalls[SYS_CREATE] = &sys_create;
    syscalls[SYS_REMOVE] = &sys_remove;
    syscalls[SYS_OPEN] = &sys_open;
    syscalls[SYS_WRITE] = &sys_write;
    syscalls[SYS_SEEK] = &sys_seek;
    syscalls[SYS_TELL] = &sys_tell;
    syscalls[SYS_CLOSE] = &sys_close;
    syscalls[SYS_READ] = &sys_read;
    syscalls[SYS_FILESIZE] = &sys_filesize;
}
```

### syscall_handler()

#### 作用

用户的命令会被终端识别，并把命令的参数压入栈。所以系统调用号是存放在栈顶的，在这个函数中，需要弹出用户栈的参数，取出系统调用号，再按照这个系统调用号去查找在`syscall_init()`中定义的`syscall`数组，找到对应的系统调用并实现

#### 实现

```c
/* Smplify the code to maintain the code more efficiently */
static void
syscall_handler(struct intr_frame *f UNUSED)
{
    //Baoer:intr_frame: interrupt stack frame
    /* For Task2 practice, just add 1 to its first argument, and print its result */
    int *p = f->esp;  //Baoer:save stack pointer
    check_ptr2(p + 1);  //Baoer: check if is valid
    int type = *(int *)f->esp;  //Baoer:record the system call num at the top of the stack
    if (type <= 0 || type >= max_syscall)
    {
        exit_special();   //Baoer:wrong num,exit
    }
    syscalls[type](f);  //Baoer: right num,check and run
}
```

### syscall_halt()

> 说明：通过调用终止Pintos shutdown_power_off() (在`devices/shutdown.h`中声明)
>
> 这应该很少使用，因为您会丢失一些有关可能的死锁情况等的信息

实现：

直接调用`shutdown_power_off()`即可

```c
#include <devices/shutdown.h>
void sys_halt(struct intr_frame *f)
{
    shutdown_power_off();
}
```

### syscall_exit()

> 说明：终止当前用户程序，将`status`返回给内核，如果其父进程在等待它，这就是要返回的状态。通常`status0`表示成功，非零值表示错误

实现：

```c
/* Do sytem exit */
void sys_exit(struct intr_frame *f)
{
    uint32_t *user_ptr = f->esp;
    check_ptr2(user_ptr + 1);
    *user_ptr++;
    /* record the exit status of the process */
    thread_current()->st_exit = *user_ptr;
    thread_exit();
}
```

### syscall_exec()

> 说明：运行名称在`cmd_line`中给出的可执行文件，传递任何给定的参数，并返回新进程的pid。如果程序因任何原因无法加载或运行，则必须返回pid -1。因此父进程不能从exec中返回直到它知道子进程是否成功加载了它的可执行文件。必须使用适当的同步来确保这一点

调用`process.c`中的`process_execute()`运行进程

```c
/* Do sytem exec */
void sys_exec(struct intr_frame *f)
{
    uint32_t *user_ptr = f->esp;
    check_ptr2(user_ptr + 1);
    check_ptr2(*(user_ptr + 1));  //Baoer:check if the file is valid, not valid return -1
    *user_ptr++;
    f->eax = process_execute((char *)*user_ptr);  //valid, do process_execute()
}
```

### syscall_wait()

> 说明：

## 参考资料

https://zhuanlan.zhihu.com/p/343328700

https://blog.csdn.net/weixin_44765402/article/details/111089137

https://www.dengzexuan.top/2021/05/pintos-project2